"""
Database models for pentesting module.

Models:
- PentestingLog: Stores scan history and audit trail
"""

from crm.models import db
from datetime import datetime
from config import SCHEMA


class PentestingLog(db.Model):
    """Pentesting scan log and audit trail."""
    
    __tablename__ = 'pentesting_logs'
    __table_args__ = {'schema': SCHEMA}

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey(f'{SCHEMA}.users.id'), nullable=False, index=True)
    
    # Scan details
    domain = db.Column(db.String(255), nullable=False, index=True)
    action = db.Column(db.String(50), default='scan')  # scan, ai_analysis, export
    
    # Results
    security_score = db.Column(db.Integer, default=0)  # 0-100
    findings_count = db.Column(db.Integer, default=0)
    findings_data = db.Column(db.JSON, default={})  # Full scan results
    ai_analysis = db.Column(db.Text)  # AI-generated explanation
    
    # Timestamps
    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationship to user
    user = db.relationship('User', backref=db.backref('pentesting_logs', lazy='dynamic'))

    def __repr__(self):
        return f'<PentestingLog {self.user_id} - {self.domain} - {self.security_score}>'

    @property
    def risk_level(self):
        """Determine risk level from security score."""
        if self.security_score >= 80:
            return 'LOW'
        elif self.security_score >= 60:
            return 'MEDIUM'
        elif self.security_score >= 40:
            return 'HIGH'
        else:
            return 'CRITICAL'

    def to_dict(self):
        """Convert to dictionary for JSON serialization."""
        return {
            'id': self.id,
            'domain': self.domain,
            'security_score': self.security_score,
            'risk_level': self.risk_level,
            'findings_count': self.findings_count,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }


class PentestingSubscriptionQuota(db.Model):
    """Track pentesting API usage per subscription."""
    
    __tablename__ = 'pentesting_quotas'
    __table_args__ = {'schema': SCHEMA}

    id = db.Column(db.Integer, primary_key=True)
    subscription_id = db.Column(db.Integer, db.ForeignKey(f'{SCHEMA}.subscriptions.id'), unique=True)
    
    # Usage tracking
    scans_this_month = db.Column(db.Integer, default=0)
    ai_analyses_this_month = db.Column(db.Integer, default=0)
    
    # Limits (for future dynamic pricing)
    monthly_scan_limit = db.Column(db.Integer, default=50)  # Pro: 50, Enterprise: 1000
    
    # Dates
    month_start = db.Column(db.DateTime, default=datetime.utcnow)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    subscription = db.relationship('Subscription', backref='pentesting_quota')

    def __repr__(self):
        return f'<PentestingQuota {self.subscription_id} - {self.scans_this_month}/{self.monthly_scan_limit}>'

    def has_scans_remaining(self) -> bool:
        """Check if subscription has scans remaining this month."""
        return self.scans_this_month < self.monthly_scan_limit

    def remaining_scans(self) -> int:
        """Get number of scans remaining this month."""
        return max(0, self.monthly_scan_limit - self.scans_this_month)

    def increment_scan(self):
        """Record a scan usage."""
        self.scans_this_month += 1
        db.session.commit()

    def increment_ai_analysis(self):
        """Record an AI analysis usage."""
        self.ai_analyses_this_month += 1
        db.session.commit()
