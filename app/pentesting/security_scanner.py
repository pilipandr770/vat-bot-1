"""
Website Security Scanner module for penetration testing.

Performs safe, non-destructive security checks on websites.
Checks:
- SQL Injection vulnerabilities
- XSS (Cross-Site Scripting) vulnerabilities
- CSRF protection
- SSL/TLS configuration
- Security Headers
- Open ports
- DNSSEC status
"""

import socket
import ssl
import requests
import dns.resolver
import dns.dnssec
from urllib.parse import urlparse, urljoin
from typing import Dict, List, Tuple, Optional
import re
import logging

logger = logging.getLogger(__name__)


class WebsiteSecurityScanner:
    """Safe security scanner for website vulnerability assessment."""

    def __init__(self, timeout: int = 10):
        """Initialize scanner with configurable timeout."""
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })

    def scan_website(self, url: str) -> Dict:
        """
        Run full security scan on website.
        Returns comprehensive security report.
        """
        if not url.startswith(('http://', 'https://')):
            url = f'https://{url}'

        parsed_url = urlparse(url)
        domain = parsed_url.netloc
        base_url = f"{parsed_url.scheme}://{domain}"

        results = {
            'url': url,
            'domain': domain,
            'timestamp': None,
            'checks': {
                'ssl_tls': self._check_ssl_tls(domain),
                'security_headers': self._check_security_headers(base_url),
                'sql_injection': self._check_sql_injection(base_url),
                'xss': self._check_xss(base_url),
                'csrf': self._check_csrf(base_url),
                'open_ports': self._check_open_ports(domain),
                'dnssec': self._check_dnssec(domain),
            },
            'overall_score': 0
        }

        # Calculate overall security score
        results['overall_score'] = self._calculate_security_score(results['checks'])
        
        return results

    def _check_ssl_tls(self, domain: str) -> Dict:
        """Check SSL/TLS certificate and configuration."""
        result = {
            'status': 'FAILED',
            'issues': [],
            'details': {}
        }

        try:
            # Create SSL context
            context = ssl.create_default_context()
            
            with socket.create_connection((domain, 443), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=domain) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()

                    # Check certificate validity
                    if cert:
                        result['details']['subject'] = dict(x[0] for x in cert['subject'])
                        result['details']['issuer'] = dict(x[0] for x in cert['issuer'])

                    # Check TLS version
                    protocol_version = ssock.version()
                    result['details']['tls_version'] = protocol_version

                    if protocol_version in ['TLSv1.2', 'TLSv1.3']:
                        result['status'] = 'PASSED'
                    else:
                        result['issues'].append(
                            f"Outdated TLS version: {protocol_version}. "
                            "Use TLS 1.2 or 1.3"
                        )

                    # Check cipher strength
                    if cipher:
                        result['details']['cipher_name'] = cipher[0]
                        if 'AES' in cipher[0] or 'CHACHA' in cipher[0]:
                            if result['status'] != 'FAILED':
                                result['status'] = 'PASSED'
                        else:
                            result['issues'].append(
                                f"Weak cipher detected: {cipher[0]}"
                            )

        except Exception as e:
            result['issues'].append(f"SSL/TLS error: {str(e)}")
            logger.warning(f"SSL check failed for {domain}: {e}")

        return result

    def _check_security_headers(self, base_url: str) -> Dict:
        """Check for security headers in HTTP responses."""
        critical_headers = {
            'strict-transport-security': 'HSTS - Enforces HTTPS',
            'x-content-type-options': 'X-Content-Type-Options - Prevents MIME sniffing',
            'x-frame-options': 'X-Frame-Options - Prevents Clickjacking',
            'content-security-policy': 'CSP - Prevents XSS attacks',
            'x-xss-protection': 'X-XSS-Protection - Browser XSS filter',
        }

        result = {
            'status': 'FAILED',
            'missing_headers': [],
            'present_headers': {},
            'issues': []
        }

        try:
            response = self.session.head(base_url, timeout=self.timeout, allow_redirects=True)
            
            found_critical = 0
            for header, description in critical_headers.items():
                header_value = response.headers.get(header)
                
                if header_value:
                    result['present_headers'][header] = header_value
                    found_critical += 1
                else:
                    result['missing_headers'].append(description)
                    result['issues'].append(
                        f"Missing {description}"
                    )

            # Calculate status based on found headers
            if found_critical >= 4:
                result['status'] = 'PASSED'
            elif found_critical >= 2:
                result['status'] = 'WARNING'

        except Exception as e:
            result['issues'].append(f"Header check error: {str(e)}")
            logger.warning(f"Header check failed for {base_url}: {e}")

        return result

    def _check_sql_injection(self, base_url: str) -> Dict:
        """Check for common SQL injection vulnerabilities."""
        result = {
            'status': 'PASSED',
            'vulnerabilities': [],
            'issues': [],
            'details': {
                'test_payloads': [
                    "' OR '1'='1",
                    "1 UNION SELECT NULL--",
                    "admin'--",
                    "1' AND '1'='1"
                ],
                'safe_test': True
            }
        }

        # Test payloads (safe - no actual data extraction)
        test_params = {
            'search': "' OR '1'='1",
            'id': "1 UNION SELECT NULL--",
            'email': "admin'--"
        }

        try:
            for param, payload in test_params.items():
                try:
                    response = self.session.get(
                        base_url,
                        params={param: payload},
                        timeout=self.timeout
                    )

                    # Look for error patterns that might indicate vulnerability
                    error_patterns = [
                        r'SQL.*error',
                        r'mysql.*error',
                        r'postgresql.*error',
                        r'oracle.*error',
                        r'syntax.*error',
                        r'unexpected.*end'
                    ]

                    response_text = response.text.lower()
                    for pattern in error_patterns:
                        if re.search(pattern, response_text):
                            result['vulnerabilities'].append({
                                'param': param,
                                'payload': payload,
                                'indicator': 'SQL error in response'
                            })
                            result['status'] = 'WARNING'

                except Exception as e:
                    logger.debug(f"Error testing SQL injection: {e}")

        except Exception as e:
            result['issues'].append(f"SQL injection check error: {str(e)}")

        return result

    def _check_xss(self, base_url: str) -> Dict:
        """Check for XSS vulnerabilities."""
        result = {
            'status': 'PASSED',
            'vulnerabilities': [],
            'issues': [],
            'details': {
                'test_payloads': [
                    '<script>alert("XSS")</script>',
                    '"><script>alert(1)</script>',
                    'javascript:alert(1)',
                    '<img src=x onerror="alert(1)">'
                ],
                'safe_test': True
            }
        }

        test_params = {
            'search': '<script>alert("XSS")</script>',
            'comment': '"><script>alert(1)</script>',
            'name': '<img src=x onerror="alert(1)">'
        }

        try:
            for param, payload in test_params.items():
                try:
                    response = self.session.get(
                        base_url,
                        params={param: payload},
                        timeout=self.timeout
                    )

                    # Check if payload is reflected in response without encoding
                    if payload in response.text:
                        result['vulnerabilities'].append({
                            'param': param,
                            'payload': payload,
                            'vulnerability': 'Reflected XSS - unencoded output'
                        })
                        result['status'] = 'WARNING'
                    
                    # Check for HTML encoding
                    encoded_payload = payload.replace('<', '&lt;').replace('>', '&gt;')
                    if encoded_payload in response.text:
                        # Properly encoded - not vulnerable
                        pass

                except Exception as e:
                    logger.debug(f"Error testing XSS: {e}")

        except Exception as e:
            result['issues'].append(f"XSS check error: {str(e)}")

        return result

    def _check_csrf(self, base_url: str) -> Dict:
        """Check for CSRF protection."""
        result = {
            'status': 'WARNING',
            'has_csrf_token': False,
            'methods_checked': ['GET', 'POST'],
            'issues': []
        }

        try:
            response = self.session.get(base_url, timeout=self.timeout)
            
            # Look for CSRF tokens in various forms
            csrf_indicators = [
                r'csrf_token',
                r'_token',
                r'authenticity_token',
                r'xsrf-token',
                r'x-csrf-token'
            ]

            response_text = response.text.lower()
            for indicator in csrf_indicators:
                if re.search(indicator, response_text):
                    result['has_csrf_token'] = True
                    result['status'] = 'PASSED'
                    break

            if not result['has_csrf_token']:
                result['issues'].append(
                    'No CSRF token detected in forms. '
                    'Implement CSRF protection middleware.'
                )

        except Exception as e:
            result['issues'].append(f"CSRF check error: {str(e)}")

        return result

    def _check_open_ports(self, domain: str) -> Dict:
        """Check for commonly exploited open ports."""
        common_ports = {
            21: 'FTP',
            22: 'SSH',
            23: 'Telnet',
            25: 'SMTP',
            53: 'DNS',
            80: 'HTTP',
            110: 'POP3',
            143: 'IMAP',
            443: 'HTTPS',
            3306: 'MySQL',
            5432: 'PostgreSQL',
            27017: 'MongoDB',
            6379: 'Redis',
        }

        result = {
            'status': 'PASSED',
            'open_ports': [],
            'issues': [],
            'unexpected_open': []
        }

        for port, service in common_ports.items():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                
                connection_result = sock.connect_ex((domain, port))
                sock.close()

                if connection_result == 0:
                    result['open_ports'].append({
                        'port': port,
                        'service': service,
                        'status': 'OPEN'
                    })

                    # Flag unexpected open ports
                    if port not in [80, 443]:
                        result['unexpected_open'].append(port)
                        result['status'] = 'WARNING'
                        result['issues'].append(
                            f"Port {port} ({service}) is open and accessible. "
                            "Ensure it's intentionally exposed."
                        )

            except socket.timeout:
                pass
            except Exception as e:
                logger.debug(f"Error checking port {port}: {e}")

        return result

    def _check_dnssec(self, domain: str) -> Dict:
        """Check DNSSEC status."""
        result = {
            'status': 'WARNING',
            'dnssec_enabled': False,
            'issues': [],
            'details': {}
        }

        try:
            resolver = dns.resolver.Resolver()

            # Check if DNSSEC is enabled by looking for DNSKEY records
            try:
                # Query for DNSKEY records - if they exist, DNSSEC is enabled
                dnskey_response = resolver.resolve(domain, 'DNSKEY')

                if dnskey_response and len(dnskey_response) > 0:
                    result['dnssec_enabled'] = True
                    result['status'] = 'PASSED'
                    result['details']['dnskey_records_found'] = len(dnskey_response)
                else:
                    result['issues'].append(
                        'No DNSKEY records found. DNSSEC is not enabled for this domain.'
                    )

            except dns.resolver.NXDOMAIN:
                result['issues'].append('Domain does not exist')

            except dns.resolver.NoAnswer:
                result['issues'].append(
                    'No DNSKEY records found. DNSSEC is not enabled for this domain.'
                )

            except dns.dnssec.ValidationFailure:
                result['issues'].append('DNSSEC validation failed')

        except Exception as e:
            result['issues'].append(f"DNSSEC check error: {str(e)}")
            logger.warning(f"DNSSEC check failed for {domain}: {e}")

        return result

    def _calculate_security_score(self, checks: Dict) -> int:
        """Calculate overall security score (0-100)."""
        score = 100
        weights = {
            'ssl_tls': 25,
            'security_headers': 20,
            'sql_injection': 20,
            'xss': 15,
            'csrf': 10,
            'open_ports': 5,
            'dnssec': 5,
        }

        for check_name, weight in weights.items():
            check = checks.get(check_name, {})
            status = check.get('status', 'FAILED')

            if status == 'FAILED':
                score -= weight
            elif status == 'WARNING':
                score -= (weight * 0.5)

        return max(0, score)

    def get_risk_level(self, score: int) -> str:
        """Determine risk level from score."""
        if score >= 80:
            return 'LOW'
        elif score >= 60:
            return 'MEDIUM'
        elif score >= 40:
            return 'HIGH'
        else:
            return 'CRITICAL'
