"""
Pentesting API routes and endpoints.

Provides endpoints for website security scanning and analysis.
Available only for PRO and ENTERPRISE users.
"""

from flask import Blueprint, request, jsonify, current_app, render_template
from flask_login import login_required, current_user
from .security_scanner import WebsiteSecurityScanner
from .ai_analyzer import SecurityAnalyzer
from .models import PentestingLog, PentestingSubscriptionQuota
from crm.models import db
from datetime import datetime, timedelta
import logging
from functools import wraps

logger = logging.getLogger(__name__)

pentesting = Blueprint('pentesting', __name__, url_prefix='/api/pentesting')


def require_subscription(f):
    """Decorator to check if user has active subscription for pentesting."""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not current_user.is_authenticated:
            return jsonify({'error': 'Authentication required'}), 401

        # Admins can always use
        if current_user.is_admin:
            return f(*args, **kwargs)

        # Check subscription
        sub = current_user.active_subscription
        if not sub or sub.plan not in ['pro', 'enterprise']:
            return jsonify({
                'error': 'Pentesting available for PRO and ENTERPRISE users only',
                'required_plan': 'PRO'
            }), 403

        return f(*args, **kwargs)

    return decorated_function


@login_required
@require_subscription
def scanner_page():
    """Display the website security scanner page."""
    return render_template('pentesting/scanner.html')


@pentesting.route('/scan', methods=['POST'])
@login_required
@require_subscription
def scan_website():
    """
    Scan website for security vulnerabilities.
    
    Request body:
    {
        "url": "example.com",
        "include_ai_analysis": true,
        "language": "de"
    }
    
    Returns:
    {
        "status": "success",
        "scan_id": "scan_123456",
        "results": {...},
        "analysis": {...},
        "timestamp": "2024-01-16T10:30:00Z"
    }
    """
    try:
        data = request.get_json()
        url = data.get('url', '').strip()

        if not url:
            return jsonify({'error': 'URL is required'}), 400

        # Validate URL format
        if not url.startswith(('http://', 'https://', 'www.')):
            if '.' not in url:
                return jsonify({'error': 'Invalid URL format'}), 400

        # Check rate limiting
        if not _check_rate_limit(current_user.id, 'pentesting'):
            return jsonify({
                'error': 'Rate limit exceeded',
                'message': 'Maximum scans per day exceeded for your plan',
                'retry_after': 3600
            }), 429

        # Perform security scan
        scanner = WebsiteSecurityScanner(timeout=10)
        scan_results = scanner.scan_website(url)
        scan_results['timestamp'] = datetime.utcnow().isoformat()

        # Add AI analysis if requested
        analysis = None
        if data.get('include_ai_analysis', False):
            language = data.get('language', 'de')
            analyzer = SecurityAnalyzer(
                api_key=current_app.config.get('OPENAI_API_KEY')
            )
            analysis = analyzer.analyze_results(scan_results, language)

            # Track OpenAI usage
            current_user.increment_api_usage()

        # Log the scan
        _log_pentesting_activity(current_user.id, url, 'scan')

        return jsonify({
            'status': 'success',
            'scan_results': scan_results,
            'ai_analysis': analysis,
            'timestamp': scan_results['timestamp']
        }), 200

    except Exception as e:
        logger.error(f"Pentesting scan error: {e}", exc_info=True)
        return jsonify({
            'error': 'Scan failed',
            'message': str(e)
        }), 500


@pentesting.route('/quick-scan', methods=['POST'])
@login_required
@require_subscription
def quick_scan():
    """
    Quick security scan with key findings only.
    Faster than full scan, returns top issues only.
    
    Request body:
    {
        "url": "example.com",
        "language": "de"
    }
    """
    try:
        data = request.get_json()
        url = data.get('url', '').strip()

        if not url:
            return jsonify({'error': 'URL is required'}), 400

        # Perform security scan (quick mode)
        scanner = WebsiteSecurityScanner(timeout=5)
        scan_results = scanner.scan_website(url)

        # Get quick tips from analyzer
        analyzer = SecurityAnalyzer()
        language = data.get('language', 'de')
        tips = analyzer.get_quick_tips(scan_results, language, max_tips=5)

        return jsonify({
            'status': 'success',
            'security_score': scan_results['overall_score'],
            'risk_level': scanner.get_risk_level(scan_results['overall_score']),
            'top_issues': tips,
            'timestamp': datetime.utcnow().isoformat()
        }), 200

    except Exception as e:
        logger.error(f"Quick scan error: {e}", exc_info=True)
        return jsonify({
            'error': 'Quick scan failed',
            'message': str(e)
        }), 500


@pentesting.route('/reports', methods=['GET'])
@login_required
@require_subscription
def get_scan_history():
    """
    Get user's pentesting scan history.
    
    Query parameters:
    - limit: number of scans (default: 20)
    - offset: pagination offset (default: 0)
    """
    try:
        limit = min(int(request.args.get('limit', 20)), 100)
        offset = int(request.args.get('offset', 0))

        # Get from database
        scans = db.session.query(PentestingLog)\
            .filter(PentestingLog.user_id == current_user.id)\
            .order_by(PentestingLog.created_at.desc())\
            .limit(limit)\
            .offset(offset)\
            .all()

        return jsonify({
            'status': 'success',
            'scans': [
                {
                    'id': scan.id,
                    'domain': scan.domain,
                    'security_score': scan.security_score,
                    'timestamp': scan.created_at.isoformat(),
                    'findings_count': scan.findings_count
                }
                for scan in scans
            ],
            'total': db.session.query(PentestingLog)\
                .filter(PentestingLog.user_id == current_user.id).count()
        }), 200

    except Exception as e:
        logger.error(f"History retrieval error: {e}")
        return jsonify({'error': 'Failed to retrieve scan history'}), 500


@pentesting.route('/report/<int:scan_id>', methods=['GET'])
@login_required
@require_subscription
def get_scan_report(scan_id):
    """Get detailed report for a specific scan."""
    try:
        scan = db.session.query(PentestingLog)\
            .filter(
                PentestingLog.id == scan_id,
                PentestingLog.user_id == current_user.id
            )\
            .first()

        if not scan:
            return jsonify({'error': 'Scan not found'}), 404

        return jsonify({
            'status': 'success',
            'scan': {
                'id': scan.id,
                'domain': scan.domain,
                'timestamp': scan.created_at.isoformat(),
                'security_score': scan.security_score,
                'findings': scan.findings_data,
                'ai_analysis': scan.ai_analysis
            }
        }), 200

    except Exception as e:
        logger.error(f"Report retrieval error: {e}")
        return jsonify({'error': 'Failed to retrieve report'}), 500


@pentesting.route('/status', methods=['GET'])
@login_required
def get_api_status():
    """Get pentesting API status and user's quota."""
    sub = current_user.active_subscription

    status = {
        'available': False,
        'user_plan': 'free',
        'message': 'Pentesting available for PRO and ENTERPRISE users'
    }

    if current_user.is_admin:
        status['available'] = True
        status['user_plan'] = 'admin'
    elif sub and sub.plan in ['pro', 'enterprise']:
        status['available'] = True
        status['user_plan'] = sub.plan
        status['scans_remaining'] = _get_remaining_scans(current_user.id)

    return jsonify(status), 200


def _check_rate_limit(user_id: int, action: str) -> bool:
    """Check if user has not exceeded rate limits."""
    from datetime import datetime, timedelta

    # Get user's subscription
    user = db.session.query(current_user.__class__).get(user_id)
    if not user:
        return False

    sub = user.active_subscription

    # Limits per plan
    limits = {
        'pro': 50,  # 50 scans per day
        'enterprise': 1000,  # unlimited basically
        'admin': 10000
    }

    if user.is_admin:
        plan = 'admin'
    else:
        plan = sub.plan if sub else 'free'

    limit = limits.get(plan, 0)

    if limit == 0:
        return False

    # Count scans in last 24 hours
    today = datetime.utcnow() - timedelta(days=1)
    count = db.session.query(PentestingLog)\
        .filter(
            PentestingLog.user_id == user_id,
            PentestingLog.created_at >= today
        ).count()

    return count < limit


def _get_remaining_scans(user_id: int) -> int:
    """Get remaining scans for user today."""
    from datetime import datetime, timedelta

    user = db.session.query(current_user.__class__).get(user_id)
    if not user:
        return 0

    sub = user.active_subscription
    limit = 50 if (sub and sub.plan == 'pro') else 1000

    today = datetime.utcnow() - timedelta(days=1)
    count = db.session.query(PentestingLog)\
        .filter(
            PentestingLog.user_id == user_id,
            PentestingLog.created_at >= today
        ).count()

    return max(0, limit - count)


def _log_pentesting_activity(user_id: int, domain: str, action: str):
    """Log pentesting activity for audit trail."""
    try:
        log = PentestingLog(
            user_id=user_id,
            domain=domain,
            action=action,
            created_at=datetime.utcnow()
        )
        db.session.add(log)
        db.session.commit()
    except Exception as e:
        logger.warning(f"Failed to log activity: {e}")


# Database model for pentesting logs
class PentestingLog:
    """Store pentesting scan logs."""
    __tablename__ = 'pentesting_logs'

    def __init__(self, user_id, domain, action, created_at=None):
        self.user_id = user_id
        self.domain = domain
        self.action = action
        self.created_at = created_at or datetime.utcnow()
